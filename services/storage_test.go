package services

import (
	"context"
	"errors"
	"github.com/biomaks/feederBot/settings"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"os"
	"testing"
	"time"
)

// MockClientInterface is an autogenerated mock type for the ClientInterface type
type MockClientInterface struct {
	mock.Mock
}

// Connect provides a mock function with given fields:
func (_m *MockClientInterface) Connect() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Database provides a mock function with given fields: _a0
func (_m *MockClientInterface) Database(_a0 string) DatabaseInterface {
	ret := _m.Called(_a0)

	var r0 DatabaseInterface
	if rf, ok := ret.Get(0).(func(string) DatabaseInterface); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(DatabaseInterface)
		}
	}

	return r0
}

// StartSession provides a mock function with given fields:
func (_m *MockClientInterface) StartSession() (mongo.Session, error) {
	ret := _m.Called()

	var r0 mongo.Session
	if rf, ok := ret.Get(0).(func() mongo.Session); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(mongo.Session)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollectionInterface is an autogenerated mock type for the CollectionInterface type
type MockCollectionInterface struct {
	mock.Mock
}

// Find provides a mock function with given fields: ctx, filter, opt
func (_m *MockCollectionInterface) Find(ctx context.Context, filter interface{}, opt *options.FindOptions) CursorInterface {
	ret := _m.Called(ctx, filter, opt)

	var r0 CursorInterface
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, *options.FindOptions) CursorInterface); ok {
		r0 = rf(ctx, filter, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(CursorInterface)
		}
	}

	return r0
}

// InsertOne provides a mock function with given fields: ctx, document
func (_m *MockCollectionInterface) InsertOne(ctx context.Context, document interface{}) (interface{}, error) {
	ret := _m.Called(ctx, document)

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(context.Context, interface{}) interface{}); ok {
		r0 = rf(ctx, document)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, interface{}) error); ok {
		r1 = rf(ctx, document)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCursorInterface is an autogenerated mock type for the CursorInterface type
type MockCursorInterface struct {
	mock.Mock
}

// Close provides a mock function with given fields: ctx
func (_m *MockCursorInterface) Close(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Decode provides a mock function with given fields: _a0
func (_m *MockCursorInterface) Decode(_a0 interface{}) error {
	ret := _m.Called(_a0)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Err provides a mock function with given fields:
func (_m *MockCursorInterface) Err() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Next provides a mock function with given fields: ctx
func (_m *MockCursorInterface) Next(ctx context.Context) bool {
	ret := _m.Called(ctx)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context) bool); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockDatabaseInterface is an autogenerated mock type for the DatabaseInterface type
type MockDatabaseInterface struct {
	mock.Mock
}

// Client provides a mock function with given fields:
func (_m *MockDatabaseInterface) Client() ClientInterface {
	ret := _m.Called()

	var r0 ClientInterface
	if rf, ok := ret.Get(0).(func() ClientInterface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ClientInterface)
		}
	}

	return r0
}

// Collection provides a mock function with given fields: name
func (_m *MockDatabaseInterface) Collection(name string) CollectionInterface {
	ret := _m.Called(name)

	var r0 CollectionInterface
	if rf, ok := ret.Get(0).(func(string) CollectionInterface); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(CollectionInterface)
		}
	}

	return r0
}

func TestStorage(t *testing.T) {

	var dbMock DatabaseInterface
	var collectionMock CollectionInterface
	var cursorMock CursorInterface

	dbMock = &MockDatabaseInterface{}
	collectionMock = &MockCollectionInterface{}
	cursorMock = &MockCursorInterface{}

	t.Run("test FindAlerts", func(t *testing.T) {
		ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)
		collectionMock.(*MockCollectionInterface).
			On("Find", ctx, bson.M{}, options.Find().SetSort(bson.D{{
				Key:   "",
				Value: -1,
			}})).
			Return(cursorMock)
		dbMock.(*MockDatabaseInterface).
			On("Collection", "alerts").
			Return(collectionMock)

		cursorMock.(*MockCursorInterface).On("Next", ctx).Return(false)
		cursorMock.(*MockCursorInterface).On("Close", ctx).Return(nil)
		cursorMock.(*MockCursorInterface).On("Err").Return(nil)

		alertDb := NewMongoDatabase(dbMock)

		alerts := alertDb.FindAlerts(ctx, bson.M{}, "")
		assert.Empty(t, alerts)
	})

	t.Run("test FindAlerts error", func(t *testing.T) {
		ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)

		cursorMock.(*MockCursorInterface).On("Next", ctx).Return(false)
		cursorMock.(*MockCursorInterface).On("Close", ctx).Return(nil)
		cursorMock.(*MockCursorInterface).On("Err").Return(errors.New("failed"))
		collectionMock.(*MockCollectionInterface).
			On("Find", ctx, bson.D{}, options.Find().SetSort(bson.D{{
				Key:   "",
				Value: -1,
			}})).
			Return(cursorMock)
		dbMock.(*MockDatabaseInterface).
			On("Collection", "alerts").
			Return(collectionMock)

		alertDb := NewMongoDatabase(dbMock)

		assert.Panics(t, func() {
			alertDb.FindAlerts(ctx, bson.M{}, "")
		})
	})

	t.Run("test SaveAlert", func(t *testing.T) {
		ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)
		alert := Alert{}

		collectionMock.(*MockCollectionInterface).
			On("InsertOne", ctx, alert).
			Return(bson.M{}, nil)
		dbMock.(*MockDatabaseInterface).
			On("Collection", "alerts").
			Return(collectionMock)
		alertDb := NewMongoDatabase(dbMock)
		result, err := alertDb.SaveAlert(ctx, alert)

		assert.Nil(t, err)
		assert.Equal(t, true, result)
	})

	t.Run("test SaveAlert panics", func(t *testing.T) {
		ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)
		alert := Alert{}

		collectionMock.(*MockCollectionInterface).
			On("InsertOne", ctx, alert).
			Return(nil, errors.New("error on test SaveAlert panics"))
		dbMock.(*MockDatabaseInterface).
			On("Collection", "alerts").
			Return(collectionMock)
		alertDb := NewMongoDatabase(dbMock)

		assert.Panics(t, func() {
			_, _ = alertDb.SaveAlert(ctx, alert)
		})

	})

	t.Run("test FindAllAlerts", func(t *testing.T) {

		ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)
		option := options.Find()
		option.SetLimit(1)
		option.SetSort(bson.D{{
			Key:   "",
			Value: 1,
		}})

		collectionMock.(*MockCollectionInterface).
			On("Find", ctx, bson.D{}, option).
			Return(cursorMock)
		dbMock.(*MockDatabaseInterface).
			On("Collection", "alerts").
			Return(collectionMock)

		cursorMock.(*MockCursorInterface).On("Next", ctx).Return(false)
		cursorMock.(*MockCursorInterface).On("Close", ctx).Return(nil)
		cursorMock.(*MockCursorInterface).On("Err").Return(nil)

		alertDb := NewMongoDatabase(dbMock)

		alerts := alertDb.FindAllAlerts(ctx, 1, "", 1)
		assert.Empty(t, alerts)
	})

	t.Run("test NewDatabase", func(t *testing.T) {
		_ = os.Setenv("SETTINGS_FILE_PATH", "../settings.toml")
		var clientInterface ClientInterface
		clientInterface = &MockClientInterface{}
		dbMock = &MockDatabaseInterface{}

		testSettings := settings.GetSettings()

		clientInterface.(*MockClientInterface).
			On("Database", mock.Anything).
			Return(dbMock)

		db := NewDatabase(testSettings, clientInterface)

		assert.Empty(t, db)
		assert.IsType(t, &MockDatabaseInterface{}, db)

	})

	t.Run("test NewClient panics", func(t *testing.T) {
		clientFunc := func(opts ...*options.ClientOptions) (*mongo.Client, error) {
			return nil, errors.New("error")
		}
		_ = os.Setenv("SETTINGS_FILE_PATH", "../settings.toml")
		var clientInterface ClientInterface
		clientInterface = &MockClientInterface{}
		dbMock = &MockDatabaseInterface{}
		testSettings := settings.GetSettings()
		clientInterface.(*MockClientInterface).
			On("Database", mock.Anything).
			Return(dbMock)
		assert.Panics(t, func() {
			_, _ = NewClient(testSettings, clientFunc)
		})

	})

	t.Run("test NewClient returns client", func(t *testing.T) {
		clientFunc := func(opts ...*options.ClientOptions) (*mongo.Client, error) {
			return &mongo.Client{}, nil
		}
		_ = os.Setenv("SETTINGS_FILE_PATH", "../settings.toml")
		var clientInterface ClientInterface
		clientInterface = &MockClientInterface{}
		dbMock = &MockDatabaseInterface{}
		testSettings := settings.GetSettings()
		clientInterface.(*MockClientInterface).
			On("Database", mock.Anything).
			Return(dbMock)
		client, err := NewClient(testSettings, clientFunc)
		assert.Nil(t, err)
		assert.IsType(t, &mongoClient{}, client)
	})

}
